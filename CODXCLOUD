import tkinter as tk
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tkinter import messagebox
from PIL import Image, ImageTk


# Global Data (Simulated Database)
USERS = {"admin": "admin123", "user1": "password1"}
BOOKS = {
    "001": {"title": "Python Programming", "author": "John Smith", "available": True, "borrowed_by": None},
    "002": {"title": "Data Structures", "author": "Jane Doe", "available": True, "borrowed_by": None},
    "003": {"title": "Algorithms", "author": "Alan Turing", "available": False, "borrowed_by": "admin"},
    "004": {"title": "Computer Networks", "author": "E. Tanenbaum", "available": True, "borrowed_by": None},
    "005": {"title": "Machine Learning", "author": "A. Ng", "available": True, "borrowed_by": None},
}

def show_info(title, msg): messagebox.showinfo(title, msg)
def show_error(title, msg): messagebox.showerror(title, msg)

class CodXCloudApp:
    def __init__(self, root: ttk.Window):
        self.root = root
        self.root.title("CodXCloud - Fullwidth Cards")
        self.root.geometry("1200x800")
        self.current_user = None
        self._card_imgs = []

        self._build_header()
        self._build_content_area()
        self.root.withdraw()
        self.create_login_window()

        """Sets up the top header with an image logo."""
    def _build_header(self):
        header = ttk.Frame(self.root, padding=8)
        header.pack(side="top", fill="x")

        # 1. Load the image
        # Replace 'assets/logo.png' with the actual path to your file
        image_path = "codxcloud logo 3.png"
        original_image = Image.open(image_path)

        # 2. Resize the image (Optional but recommended for headers)
        # Adjust (width, height) as needed. using LANCZOS for high-quality downsampling
        resized_image = original_image.resize((300, 150), Image.Resampling.LANCZOS)

        # 3. Convert to PhotoImage and STORE THE REFERENCE
        # We bind it to 'self' so the garbage collector doesn't delete it
        self.header_logo = ImageTk.PhotoImage(resized_image)

        # 4. Create the button using the 'image' argument
        title_btn = ttk.Button(
            header,
            image=self.header_logo,  # Use the stored image reference
            bootstyle="link",  # 'link' style usually removes button borders
            command=lambda: self.show_view("search")
        )
        title_btn.pack(side="left", padx=20)

        # Right dropdown menu
        right = ttk.Frame(header)
        right.pack(side="right", padx=20)
        menu_btn = ttk.Menubutton(right, text="â˜° Menu", bootstyle="secondary-outline")
        menu_btn.pack(side="right")
        menu = tk.Menu(menu_btn, tearoff=0)
        menu.add_command(label="Search", command=lambda: self.show_view("search"))
        menu.add_command(label="Borrow/Return", command=lambda: self.show_view("borrow"))
        menu.add_command(label="Profile", command=lambda: self.show_view("profile"))
        menu.add_separator()
        menu.add_command(label="Logout", command=self._logout_action)
        menu_btn["menu"] = menu

    def _build_content_area(self):
        """Sets up the main content frame."""
        self.content_frame = ttk.Frame(self.root, padding=20)
        self.content_frame.pack(fill="both", expand=True)

    def clear_content(self):
        """Destroys all widgets in the content frame."""
        for w in self.content_frame.winfo_children(): w.destroy()

    def show_view(self, view_name):
        """Switches the main application view."""
        self.clear_content()
        if view_name == "search": self._view_search_cards()
        elif view_name == "borrow": self._view_borrow_return()
        elif view_name == "profile": self._view_profile()
        else: self._view_search_cards()

    # -------------------------
    # Search Card Layout (full width)
    # -------------------------
    def _view_search_cards(self):
        """Displays the book search interface with responsive cards."""

        # --- 1. Top Search Bar ---
        top = ttk.Frame(self.content_frame)
        top.pack(fill="x", pady=(0,10))
        ttk.Label(top, text="Search Books", font=("Helvetica", 20, "bold"), bootstyle="info").pack(side="left", padx=15)
        search_entry = ttk.Entry(top, width=50)
        search_entry.pack(side="left", padx=10)
        search_type = tk.StringVar(value="Title")
        ttk.Radiobutton(top, text="Title", variable=search_type, value="Title", bootstyle="info-toolbutton").pack(side="left", padx=4)
        ttk.Radiobutton(top, text="Author", variable=search_type, value="Author", bootstyle="info-toolbutton").pack(side="left", padx=4)

        # --- 2. Scrollable Area Setup ---
        container = ttk.Frame(self.content_frame)
        container.pack(fill="both", expand=True)
        canvas = tk.Canvas(container, highlightthickness=0)
        scrollbar = ttk.Scrollbar(container, orient="vertical", command=canvas.yview)

        # 'scrollable' is the frame that holds the cards, which lives inside the canvas
        scrollable = ttk.Frame(canvas)

        # Configure scrolling and place widgets
        scrollable.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Make canvas respond to mouse wheel (Windows and Mac)
        def _on_mousewheel(event):
            if event.delta:
                canvas.yview_scroll(int(-1*(event.delta/120)), "units")
            else:
                # For Linux, event.num 4/5
                if event.num == 4:
                    canvas.yview_scroll(-3, "units")
                elif event.num == 5:
                    canvas.yview_scroll(3, "units")
        canvas.bind_all("<MouseWheel>", _on_mousewheel)
        canvas.bind_all("<Button-4>", _on_mousewheel)
        canvas.bind_all("<Button-5>", _on_mousewheel)

        # State tracker for card grid layout
        card_counter = {"i": 0}

        # --- 3. Nested Helper Functions ---

        def clear_cards():
            """Clears all cards from the scrollable frame."""
            for c in scrollable.winfo_children(): c.destroy()
            self._card_imgs.clear()

        def borrow_book(bid, btn):
            """Handles the logic for borrowing a book."""
            book = BOOKS.get(bid)
            if not self.current_user:
                show_error("Error", "Please login first")
                return

            if book and book["available"]:
                book["available"] = False
                book["borrowed_by"] = self.current_user
                btn.configure(text="Borrowed", state="disabled", bootstyle="danger")
                show_info("Success", f"Borrowed {book['title']}")
            else:
                show_error("Error", "Not available")

        # --- UPDATED make_card function with bigger design ---
        def make_card(parent, bid, book):
            """Creates and places a single book card with large styling."""
            r = card_counter["i"] // 2   # row number
            c = card_counter["i"] % 2    # column 0 or 1

            # BIGGER card frame
            card = ttk.Frame(
                parent,
                padding=(30, 30), # Increased padding
                relief="raised",
                bootstyle="secondary"
            )
            card.grid(
                row=r, column=c,
                padx=30, pady=30, # Increased grid padding/spacing
                sticky="nwe"
            )

            # allow even expansion
            parent.grid_columnconfigure(0, weight=1)
            parent.grid_columnconfigure(1, weight=1)

            # LEFT section (BIG placeholder image)
            left = ttk.Frame(card, width=200) # Increased width
            left.pack(side="left", padx=(0, 30))

            placeholder = tk.Canvas(left, width=150, height=220, highlightthickness=0) # Increased size
            placeholder.create_rectangle(0, 0, 150, 220, fill="#f1f1f1", outline="#999999")
            placeholder.create_text(75, 110, text="No\nImage", justify="center", font=("Helvetica", 12)) # Font added
            placeholder.pack()

            # MIDDLE text (BIGGER fonts)
            middle = ttk.Frame(card)
            middle.pack(side="left", fill="both", expand=True)

            ttk.Label(middle, text=book["title"], font=("Helvetica", 20, "bold")).pack(anchor="w") # Bigger title font
            ttk.Label(middle, text=f"Author: {book['author']}", font=("Helvetica", 14)).pack(anchor="w", pady=(10, 0)) # Bigger text font

            st = "Available" if book["available"] else f"Borrowed by {book['borrowed_by']}"
            ttk.Label(middle, text=f"Status: {st}", font=("Helvetica", 14)).pack(anchor="w", pady=(14, 0)) # Bigger text font

            # RIGHT section with BIGGER button
            right = ttk.Frame(card, width=200) # Increased width
            right.pack(side="right", fill="y")

            right_inner = ttk.Frame(right)
            right_inner.place(relx=0.5, rely=0.5, anchor="center")

            borrow_btn = ttk.Button(
                right_inner,
                text="Borrow",
                width=16, # Increased button width
                bootstyle="danger"
            )

            if not book["available"]:
                borrow_btn.configure(
                    text="Not Available",
                    state="disabled",
                    bootstyle="secondary"
                )

            borrow_btn.pack(pady=10) # Added vertical button padding
            # Correct command reference with proper closure
            borrow_btn.configure(command=lambda bid=bid, btn=borrow_btn: borrow_book(bid, btn))

            card_counter["i"] += 1
        # ----------------------------------------------------

        def perform_search(q, mode):
            """Filters the BOOKS data and renders the search results."""
            clear_cards()
            card_counter["i"] = 0 # Reset card counter for fresh grid layout
            q = (q or "").strip().lower()
            results = []

            # Filtering logic
            for k,v in BOOKS.items():
                if not q or \
                   (mode=="Title" and q in v["title"].lower()) or \
                   (mode=="Author" and q in v["author"].lower()):
                    results.append((k,v))

            # Display results or "No results" message
            if not results:
                # Use grid (not pack) because cards use grid; keep geometry consistent
                lbl = ttk.Label(scrollable, text="No results found.", font=("Helvetica", 12))
                lbl.grid(row=0, column=0, columnspan=2, pady=20)
                return

            for bid, book in results:
                make_card(scrollable, bid, book)

            # Re-configure canvas scroll region after adding content
            scrollable.update_idletasks()
            canvas.config(scrollregion=canvas.bbox("all"))

        # --- 4. Wire up Search Button and Initial Load ---
        ttk.Button(top, text="Search", bootstyle="primary",
                   command=lambda: perform_search(search_entry.get(), search_type.get())).pack(side="left", padx=10)

        perform_search("", "Title") # Initial display of all books

    # -------------------------
    # Borrow & Profile methods
    # -------------------------
    def _view_borrow_return(self):
        """Simple borrow/return view."""
        ttk.Label(self.content_frame, text="Borrow / Return Books", font=("Helvetica", 18, "bold")).pack(pady=20)
        form = ttk.Frame(self.content_frame)
        form.pack(pady=10)

        ttk.Label(form, text="Book ID:").grid(row=0, column=0, padx=6)
        entry = ttk.Entry(form, width=12)
        entry.grid(row=0, column=1, padx=6)

        def borrow():
            """Handles the immediate borrow action from the dedicated view."""
            bid = entry.get().strip()
            book = BOOKS.get(bid)

            if not self.current_user:
                 show_error("Error", "Please log in to borrow books.")
                 return

            if book and book["available"]:
                book["available"] = False
                book["borrowed_by"] = self.current_user
                show_info("Success", f"Successfully borrowed: {book['title']}")
                # Clear the entry after success
                entry.delete(0, tk.END)
            else:
                show_error("Error", "Invalid ID or book is already borrowed.")

        def return_book():
            """Handles the immediate return action from the dedicated view."""
            bid = entry.get().strip()
            book = BOOKS.get(bid)

            if not self.current_user:
                 show_error("Error", "Please log in.")
                 return

            if book and not book["available"] and book["borrowed_by"] == self.current_user:
                book["available"] = True
                book["borrowed_by"] = None
                show_info("Success", f"Successfully returned: {book['title']}")
                # Clear the entry after success
                entry.delete(0, tk.END)
            else:
                show_error("Error", "Invalid ID or you did not borrow this book.")

        ttk.Button(form, text="Borrow", bootstyle="danger", command=borrow).grid(row=0, column=2, padx=6)
        ttk.Button(form, text="Return", bootstyle="success", command=return_book).grid(row=0, column=3, padx=6)


    def _view_profile(self):
        """Displays the user's profile and borrowed books."""
        ttk.Label(self.content_frame, text="My Profile", font=("Helvetica", 20, "bold")).pack(pady=15)
        if not self.current_user:
            ttk.Label(self.content_frame, text="Please login first.").pack()
            return

        ttk.Label(self.content_frame, text=f"Welcome, {self.current_user}", font=("Helvetica", 14)).pack(pady=6)

        borrowed_list = []
        for bid,b in BOOKS.items():
            if b.get("borrowed_by")==self.current_user:
                borrowed_list.append(f"{bid} - {b['title']} by {b['author']}")

        if borrowed_list:
            ttk.Label(self.content_frame, text="Borrowed Books:", font=("Helvetica", 12, "bold")).pack(pady=(20,0))
            for item in borrowed_list:
                 ttk.Label(self.content_frame, text=item).pack(anchor="w", padx=40)
        else:
            ttk.Label(self.content_frame, text="You have no books currently borrowed.", font=("Helvetica", 12, "italic")).pack(pady=10)


    # -------------------------
    # Login Window
    # -------------------------
    def create_login_window(self):
        """Creates and displays the modal login window."""
        self.login_win = tk.Toplevel(self.root)
        self.login_win.title("Login - CodXCloud")
        self.login_win.geometry("360x260")
        self.login_win.resizable(False, False)
        self.login_win.protocol("WM_DELETE_WINDOW", self.root.quit)

        frm = ttk.Frame(self.login_win, padding=12)
        frm.pack(fill="both", expand=True)

        ttk.Label(frm, text="CodXCloud Login", font=("Helvetica", 16, "bold"), bootstyle="primary").pack(pady=8)

        form = ttk.Frame(frm)
        form.pack(pady=6)

        ttk.Label(form, text="Student ID:").grid(row=0, column=0, sticky="w", padx=6, pady=6)
        self.username_entry = ttk.Entry(form, width=26)
        self.username_entry.grid(row=0, column=1, padx=6, pady=6)

        ttk.Label(form, text="Password:").grid(row=1, column=0, sticky="w", padx=6, pady=6)
        self.password_entry = ttk.Entry(form, width=26, show="*")
        self.password_entry.grid(row=1, column=1, padx=6, pady=6)

        btnf = ttk.Frame(frm); btnf.pack(pady=8)
        ttk.Button(btnf, text="Login", bootstyle="success", command=self._login_action).grid(row=0, column=0, padx=6)
        ttk.Button(btnf, text="Register", bootstyle="info", command=self._register_action).grid(row=0, column=1, padx=6)

        # Set focus to the login window and entry
        self.login_win.focus_set()
        self.login_win.grab_set()
        self.username_entry.focus_set()


    def _login_action(self):
        """Authenticates the user and opens the main application."""
        u, p = self.username_entry.get().strip(), self.password_entry.get().strip()
        if USERS.get(u) == p:
            self.current_user = u
            show_info("Welcome", f"Welcome, {u}!")
            self.login_win.destroy()
            self.root.deiconify() # Show the main window
            self.show_view("search")
        else:
            show_error("Error", "Invalid credentials")

    def _register_action(self):
        """Registers a new user (in memory)."""
        u, p = self.username_entry.get().strip(), self.password_entry.get().strip()
        if not u or not p:
            show_error("Error", "Enter credentials"); return
        if u in USERS:
            show_error("Error", "User exists"); return

        USERS[u]=p
        show_info("Success","Registered! You can login now.")
        self.username_entry.delete(0, tk.END)
        self.password_entry.delete(0, tk.END)
        self.username_entry.focus_set()

    def _logout_action(self):
        """Logs out the user and returns to the login screen."""
        if messagebox.askyesno("Logout", "Are you sure you want to log out?"):
            self.current_user=None
            self.root.withdraw()
            self.create_login_window()

if __name__ == "__main__":
    root = ttk.Window(themename="cosmo")
    app = CodXCloudApp(root)
    root.mainloop()


